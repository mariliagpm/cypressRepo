"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.commandParams = exports.requestName = exports.stringify = exports.stepMessage = exports.withTry = exports.commandLogs = exports.filterCommandLog = exports.logNameFn = exports.ignoreAllCommands = exports.COMMAND_REQUEST = exports.ARGS_TRIM_AT = void 0;
const _1 = require("./");
exports.ARGS_TRIM_AT = 200;
exports.COMMAND_REQUEST = 'request';
const ignoreAllCommands = (ignoreCommands) => {
    const cmds = [...ignoreCommands(), 'should', 'then', 'allure', 'doSyncCommand', 'end-logGroup', 'within-restore']
        .filter(t => t.trim() !== '')
        .map(x => new RegExp(`^${x.replace(/\*/g, '.*')}$`));
    return {
        includes(ttl) {
            return cmds.some(t => t.test(ttl));
        },
    };
};
exports.ignoreAllCommands = ignoreAllCommands;
const logNameFn = (attribute) => {
    var _a, _b;
    if ((attribute === null || attribute === void 0 ? void 0 : attribute.name) === exports.COMMAND_REQUEST) {
        return attribute === null || attribute === void 0 ? void 0 : attribute.name;
    }
    return (_b = (_a = attribute === null || attribute === void 0 ? void 0 : attribute.displayName) !== null && _a !== void 0 ? _a : attribute === null || attribute === void 0 ? void 0 : attribute.name) !== null && _b !== void 0 ? _b : 'no-log';
};
exports.logNameFn = logNameFn;
const filterCommandLog = (command, ignoreCommands) => {
    var _a, _b;
    const cmdAttrs = command === null || command === void 0 ? void 0 : command.attributes;
    const cmdLogs = (_a = cmdAttrs === null || cmdAttrs === void 0 ? void 0 : cmdAttrs.logs) !== null && _a !== void 0 ? _a : [];
    return ((_b = cmdLogs.filter(log => {
        var _a, _b, _c;
        const attr = log.attributes;
        const logName = (0, exports.logNameFn)(attr);
        const logMessageAttr = (_a = attr === null || attr === void 0 ? void 0 : attr.message) !== null && _a !== void 0 ? _a : '';
        const cmdMsg = (_c = (_b = (0, exports.commandParams)(command)) === null || _b === void 0 ? void 0 : _b.message) !== null && _c !== void 0 ? _c : '';
        const logMessage = (0, exports.stepMessage)(logName, logMessageAttr === 'null' ? '' : logMessageAttr);
        // console.log(`cmdMsg     ${cmdMsg}`);
        // console.log(`logMessage ${logMessage}`);
        const equalMessages = logMessage === cmdMsg || logMessage.replace(/"/g, '') == cmdMsg.replace(/"/g, '');
        const isRequest = logName === exports.COMMAND_REQUEST;
        const isIts = /its:\s*\..*/.test(logMessage); // its already logged as command
        const ignoredLog = (0, exports.ignoreAllCommands)(ignoreCommands).includes(logName);
        const isLogMsgEqCommandName = logMessage === (cmdAttrs === null || cmdAttrs === void 0 ? void 0 : cmdAttrs.name);
        const isGroupStart = !!(attr === null || attr === void 0 ? void 0 : attr.groupStart);
        const noLogConditions = [equalMessages, isRequest, isIts, ignoredLog, isLogMsgEqCommandName];
        const result = noLogConditions.every(c => !c) || isGroupStart;
        // console.log(noLogConditions);
        // console.log(`logCondition: ${logCondition}`);
        // console.log(`result: ${result}`);
        // console.log('----');
        return result;
    })) !== null && _b !== void 0 ? _b : []);
};
exports.filterCommandLog = filterCommandLog;
const commandLogs = (command) => {
    var _a;
    const cmdAttrs = command === null || command === void 0 ? void 0 : command.attributes;
    const cmdLogs = (_a = cmdAttrs === null || cmdAttrs === void 0 ? void 0 : cmdAttrs.logs) !== null && _a !== void 0 ? _a : [];
    return cmdLogs;
};
exports.commandLogs = commandLogs;
const withTry = (message, callback) => {
    try {
        callback();
    }
    catch (err) {
        const e = err;
        (0, _1.logWithPackage)('error', `could do '${message}': ${e.message}`);
        // eslint-disable-next-line no-console
        console.error(e.stack);
    }
};
exports.withTry = withTry;
const stepMessage = (name, args) => {
    const isLong = args && args.length > exports.ARGS_TRIM_AT;
    const isAssertLog = name === 'assert';
    const isNonZeroArgs = args && args.length > 0;
    const stringArgs = isNonZeroArgs ? `${args}` : '';
    const argsLineDarft = isLong && !isAssertLog ? '' : stringArgs;
    const argsLine = argsLineDarft.replace('function(){}', '').trim();
    const argsAndName = argsLine === '' ? `${name}` : `${name}: ${argsLine}`;
    const message = name.trim() === '' ? `${argsLine}` : argsAndName;
    return isAssertLog ? message : message.replace(/\*\*/g, '');
};
exports.stepMessage = stepMessage;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const stringify = (args, isJSON, indent) => {
    const getArr = () => {
        try {
            if (Array.isArray(args)) {
                return `[${args.map(a => (0, exports.stringify)(a, isJSON, indent)).join(',')}]`;
            }
            else {
                return convertEmptyObj(args, isJSON, indent);
            }
        }
        catch (err) {
            return 'could not stringify';
        }
    };
    if (typeof args === 'string') {
        try {
            return (0, exports.stringify)(JSON.parse(args), isJSON, indent);
        }
        catch (err) {
            return `${args}`;
        }
    }
    return typeof args === 'string' || typeof args === 'number' || typeof args === 'boolean' ? `${args}` : getArr();
};
exports.stringify = stringify;
const requestName = (url, method) => {
    return `${method}, ${url}`;
};
exports.requestName = requestName;
function formatObject(obj, indent) {
    const keys = Object.keys(obj);
    const indStr = indent !== null && indent !== void 0 ? indent : '';
    const entries = keys
        .map(key => {
        const value = obj[key];
        if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
            return `${indStr}${key}: ${formatObject(value, indent === null || indent === void 0 ? void 0 : indent.repeat(2))}`;
        }
        else if (value !== null && Array.isArray(value)) {
            `${indStr}${key}: [${value.map(v => formatObject(v, indent))}]`;
        }
        else {
            if (typeof value === 'string') {
                return `${indStr}${key}: "${value}"`;
            }
            else {
                return `${indStr}${key}: ${value}`;
            }
        }
    })
        .join(',');
    if (indent) {
        return `{\n${entries}\n${indent}}`;
    }
    return `{${entries}}`;
}
const convertEmptyObj = (obj, isJSON, indent) => {
    if (obj == null) {
        return '';
    }
    if (Object.keys(obj).length > 0) {
        try {
            if (isJSON) {
                return !indent ? JSON.stringify(obj) : JSON.stringify(obj, null, indent);
            }
            else {
                return formatObject(obj, indent);
            }
        }
        catch (e) {
            return 'could not stringify';
        }
    }
    return '';
};
const commandParams = (command) => {
    var _a, _b;
    const name = (0, exports.logNameFn)(command.attributes);
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const commandArgs = (_a = command.attributes) === null || _a === void 0 ? void 0 : _a.args;
    const state = (_b = command.state) !== null && _b !== void 0 ? _b : 'passed';
    // exclude command logs with Cypress options isLog = false
    const isLog = () => {
        try {
            if (commandArgs && Array.isArray(commandArgs)) {
                return !commandArgs.some(a => a && a.log === false);
            }
            return commandArgs.log !== false;
        }
        catch (err) {
            return false; // 'could not get log';
        }
    };
    const getArgs = () => {
        try {
            if (Array.isArray(commandArgs)) {
                return commandArgs
                    .map(arg => {
                    if (name === exports.COMMAND_REQUEST && typeof arg === 'object' && arg.method && arg.url) {
                        return (0, exports.requestName)(arg.url, arg.method);
                    }
                    return (0, exports.stringify)(arg, false);
                })
                    .filter(x => x.trim() !== '');
            }
            return [convertEmptyObj(commandArgs, false)];
        }
        catch (err) {
            return ['could not parse args'];
        }
    };
    const args = getArgs();
    return {
        name,
        args,
        message: (0, exports.stepMessage)(name, args.filter(t => t.length < exports.ARGS_TRIM_AT).join(', ')),
        isLog: isLog(),
        state,
    };
};
exports.commandParams = commandParams;
