"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.wrapHooks = void 0;
exports.mergeStepsWithSingleChild = mergeStepsWithSingleChild;
exports.removeFirstStepWhenSame = removeFirstStepWhenSame;
exports.removeStepsByName = removeStepsByName;
/**
 * Recursively merge the steps when a step has single child with the same name
 * Delete first child when it has the same name as parent
 * @param steps
 */
function mergeStepsWithSingleChild(steps) {
    function flattenStep(step) {
        while (step.steps && step.steps.length === 1 && step.steps[0].name === step.name) {
            step = step.steps[0];
        }
        if (step.steps) {
            step.steps = step.steps.map(flattenStep);
        }
        return step;
    }
    for (let i = 0; i < steps.length; i++) {
        steps[i] = flattenStep(steps[i]);
    }
}
function removeFirstStepWhenSame(steps) {
    // Helper function to process each step recursively
    function processSteps(steps) {
        return steps.map(step => {
            // Ensure `step.steps` is treated as a flat array of steps
            const flattenedSteps = flattenSteps(step.steps);
            // Recursively process each flattened step
            const processedSteps = processSteps(flattenedSteps);
            // Check if the first nested step has the same name as the current step
            if (processedSteps.length > 0 && processedSteps[0].name === step.name && processedSteps[0].steps.length === 0) {
                // Remove the first nested step
                const res = step;
                res.steps = processedSteps.slice(1);
                return res;
            }
            const res2 = step;
            res2.steps = processedSteps;
            // If no match or no steps, return as-is
            return res2;
        });
    }
    // Helper function to flatten nested arrays into a single array
    function flattenSteps(steps) {
        if (Array.isArray(steps[0])) {
            // Flatten nested arrays
            return steps[0].flatMap(s => s);
        }
        return steps;
    }
    return processSteps(steps);
}
// function removeStepsByName(steps: Step[], nameToRemove: string): Step[] {
//   const result: Step[] = [];
//
//   steps.forEach(step => {
//     if (step.name === nameToRemove) {
//       // If the step name matches, promote its children (and recursively process them)
//       const promotedSteps = removeStepsByName(step.steps, nameToRemove);
//       result.push(...promotedSteps);
//     } else {
//       // Otherwise, keep the step and recursively process its children
//       result.push({
//         ...step,
//         steps: removeStepsByName(step.steps, nameToRemove)
//       });
//     }
//   });
//
//   return result;
// }
function removeStepsByName(steps, commands) {
    const result = [];
    steps.forEach(step => {
        if (!step.name) {
            return;
        }
        if (commands.includes(step.name)) {
            // If the step name matches, promote its children
            const promotedSteps = removeStepsByName(step.steps, commands);
            result.push(...promotedSteps);
        }
        else {
            // Otherwise, keep the step and apply the function to its children
            result.push(Object.assign(Object.assign({}, step), { steps: removeStepsByName(step.steps, commands) }));
        }
    });
    return result;
}
const wrapHooks = (stepName, steps) => {
    var _a, _b, _c;
    let startIndex = undefined;
    let endIndex = undefined;
    steps.forEach((step, i) => {
        var _a, _b;
        if (((_a = step.name) === null || _a === void 0 ? void 0 : _a.startsWith(stepName)) && startIndex === undefined) {
            startIndex = i;
        }
        if (((_b = step.name) === null || _b === void 0 ? void 0 : _b.startsWith(stepName)) && startIndex !== undefined) {
            endIndex = i;
        }
    });
    if (endIndex !== undefined && startIndex !== undefined && startIndex !== endIndex) {
        const childrenBeforeEach = steps.slice(startIndex, endIndex + 1);
        const nonSuccess = childrenBeforeEach.filter(x => x.status !== 'passed');
        const status = nonSuccess.length > 0 ? nonSuccess[0].status : 'passed';
        const startTime = (_b = (_a = childrenBeforeEach[0]) === null || _a === void 0 ? void 0 : _a.start) !== null && _b !== void 0 ? _b : undefined;
        const endTime = (_c = childrenBeforeEach[childrenBeforeEach.length - 1].stop) !== null && _c !== void 0 ? _c : undefined;
        return [
            ...steps.slice(0, startIndex),
            {
                name: `${stepName}s`,
                steps: childrenBeforeEach,
                status,
                statusDetails: {},
                stage: 'finished',
                attachments: [],
                parameters: [],
                start: startTime,
                stop: endTime,
            },
            ...steps.slice(endIndex + 1),
        ];
    }
    return steps;
};
exports.wrapHooks = wrapHooks;
