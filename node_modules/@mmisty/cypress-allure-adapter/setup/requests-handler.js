"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.attachRequests = void 0;
const command_names_1 = require("../common/command-names");
const helper_1 = require("./helper");
const common_1 = require("../common");
const attachRequests = (dbg, allureAttachRequests, command, opts) => {
    var _a, _b, _c;
    const debug = (0, helper_1.logClient)(dbg);
    const maxParamLength = 70;
    const compact = (_a = opts.compactAttachments) !== null && _a !== void 0 ? _a : true;
    const indent = compact ? undefined : ' ';
    debug(command);
    const logsAttr = (_c = (_b = command.attributes) === null || _b === void 0 ? void 0 : _b.logs) !== null && _c !== void 0 ? _c : [];
    const consoleProps = logsAttr.map(t => { var _a, _b; return (_b = (_a = t.attributes) === null || _a === void 0 ? void 0 : _a.consoleProps) === null || _b === void 0 ? void 0 : _b.call(_a); });
    debug('consoleProps:');
    debug(consoleProps);
    // t.Command for less than 13.x cypress
    const logs = consoleProps.filter(t => t.name === command_names_1.COMMAND_REQUEST || t.Command === command_names_1.COMMAND_REQUEST);
    const getRequests = () => {
        const logsMapped = logs.map(t => { var _a; return (_a = t.props) !== null && _a !== void 0 ? _a : t; }); // support  cypress < 13.x
        if (logsMapped.every(t => !!t.Requests)) {
            // several requests if there are come redirects
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            return logsMapped.flatMap(t => t.Requests.map((x) => { var _a; return (Object.assign(Object.assign({}, x), { duration: (_a = t.Yielded) === null || _a === void 0 ? void 0 : _a.duration })); }));
        }
        if (logsMapped.every(t => !!t.Request)) {
            return logsMapped.map(t => { var _a; return (Object.assign(Object.assign({}, t.Request), { duration: (_a = t.Yielded) === null || _a === void 0 ? void 0 : _a.duration })); });
        }
        return undefined;
    };
    const requests = getRequests();
    if (!requests) {
        return;
    }
    const allRequests = requests.filter(r => !!r);
    allRequests.forEach((req) => {
        var _a, _b, _c, _d, _e;
        const reqHeaders = { obj: req['Request Headers'], name: 'Request Headers' };
        const reqBody = { obj: req['Request Body'], name: 'Request Body' };
        const resHeaders = { obj: req['Response Headers'], name: 'Response Headers' };
        const resBody = { obj: req['Response Body'], name: 'Response Body' };
        const resStatusParam = { name: 'Response Status', value: `${(_a = req['Response Status']) !== null && _a !== void 0 ? _a : ''}` };
        const reqUrlParam = { name: 'Request URL', value: `${(_b = req['Request URL']) !== null && _b !== void 0 ? _b : ''}` };
        const stepUrl = reqUrlParam.value.replace((_e = (_c = Cypress.config('baseUrl')) !== null && _c !== void 0 ? _c : (0, common_1.baseUrlFromUrl)((_d = Cypress.config('browserUrl')) !== null && _d !== void 0 ? _d : '')) !== null && _e !== void 0 ? _e : '', '');
        const stepStatus = resStatusParam.value !== '200' ? 'broken' : 'passed';
        /*if (reqNumber === 0) {
          Cypress.Allure.parameters({ name: 'duration', value: req.duration });
        }*/
        if (allRequests.length > 1) {
            Cypress.Allure.startStep(`request: ${resStatusParam.value} ${stepUrl}`);
        }
        const attaches = [reqBody, reqHeaders, resBody, resHeaders].map(t => (Object.assign(Object.assign({}, t), { stringified: (0, command_names_1.stringify)(t.obj, true, indent) })));
        const shortAttaches = attaches.filter(a => a.stringified.length < maxParamLength);
        const longAttaches = attaches.filter(a => a.stringified.length >= maxParamLength);
        if (allRequests.length === 1) {
            Cypress.Allure.parameters(resStatusParam);
        }
        Cypress.Allure.parameters(reqUrlParam, ...shortAttaches.map(a => ({ name: a.name, value: a.stringified })));
        if (allureAttachRequests) {
            const requests = {};
            longAttaches
                .filter(t => !!t.obj)
                .forEach(attach => {
                requests[attach.name] = attach.obj;
            });
            Cypress.Allure.attachment('requests', (0, command_names_1.stringify)(requests, true, indent), 'application/json');
        }
        if (allRequests.length > 1) {
            Cypress.Allure.endStep(stepStatus);
        }
    });
};
exports.attachRequests = attachRequests;
