"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CustomCommandsHandler = void 0;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const command_names_1 = require("../common/command-names");
const common_1 = require("../common");
class CustomCommandsHandler {
    constructor(events, ignoreCommands, wrapCustomCommandsSetup) {
        this.events = events;
        this.ignoreCommands = ignoreCommands;
        this.wrapCustomCommandsSetup = wrapCustomCommandsSetup;
        this.wrappedFunction =
            (originalFn) => (...fnargs) => {
                var _a, _b;
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                const currentCmd = (_b = (_a = Cypress).state) === null || _b === void 0 ? void 0 : _b.call(_a).current;
                this.events.emit('cmd:started:tech', currentCmd, true);
                const res = originalFn(...fnargs);
                const end = () => this.events.emit('cmd:ended:tech', currentCmd, true);
                if ((res === null || res === void 0 ? void 0 : res.then) && !(res === null || res === void 0 ? void 0 : res.should)) {
                    // for promises returned from commands
                    res.then(() => {
                        end();
                    });
                }
                else if (res === null || res === void 0 ? void 0 : res.should) {
                    res.should(() => {
                        end();
                    });
                }
                else {
                    // when function returns
                    // undefined we cannot add command at the end,
                    // so custom command will be ended immediately
                    end();
                }
                return res;
            };
    }
    wrapCustomCommandsFunction(commands, isExclude) {
        const origAdd = Cypress.Commands.add;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        Cypress.Commands.add = (...args) => {
            const fnName = args[0];
            const fn = typeof args[1] === 'function' ? args[1] : args[2];
            const opts = typeof args[1] === 'object' ? args[1] : undefined;
            if (!fnName ||
                typeof fnName !== 'string' ||
                (0, command_names_1.ignoreAllCommands)(this.ignoreCommands).includes(fnName) ||
                // wrap only specified commands
                (commands.length > 0 && commands.includes(fnName) && isExclude) ||
                (commands.length > 0 && !commands.includes(fnName) && !isExclude)) {
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                origAdd(...args);
                return;
            }
            if (fn && opts) {
                origAdd(fnName, opts, this.wrappedFunction(fn));
            }
            else if (fn) {
                origAdd(fnName, this.wrappedFunction(fn));
            }
            else {
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                origAdd(...args);
            }
        };
    }
    wrap() {
        const wrapSetup = this.wrapCustomCommandsSetup();
        if (!wrapSetup) {
            return;
        }
        const commands = Array.isArray(wrapSetup) ? wrapSetup : [];
        let isExclude = false;
        let commadsFixed = commands;
        if (!(commands === null || commands === void 0 ? void 0 : commands.every(c => c.startsWith('!'))) || !(commands === null || commands === void 0 ? void 0 : commands.every(c => !c.startsWith('!')))) {
            (0, common_1.logWithPackage)('warn', 'wrapCustomCommands environment variable - should either all start from "!" or not');
        }
        if (commands === null || commands === void 0 ? void 0 : commands.every(c => c.startsWith('!'))) {
            isExclude = true;
            commadsFixed = commands === null || commands === void 0 ? void 0 : commands.map(t => t.slice(1));
        }
        this.wrapCustomCommandsFunction(commadsFixed, isExclude);
    }
    wrapGroupedCommands() {
        const groupedCommands = ['session', 'within'];
        groupedCommands.forEach(cmd => {
            const wrappedFn = this.wrappedFunction;
            const ignoreCommands = this.ignoreCommands;
            Cypress.Commands.overwrite(cmd, function (originalFn, ...args) {
                const fn = originalFn;
                if ((0, command_names_1.ignoreAllCommands)(ignoreCommands).includes(cmd)) {
                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                    // @ts-ignore
                    return fn(...args);
                }
                return wrappedFn(fn)(...args);
            });
        });
    }
}
exports.CustomCommandsHandler = CustomCommandsHandler;
